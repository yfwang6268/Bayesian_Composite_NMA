---
title: "Bayesian Meta-Analysis using gemtc"
output: html_notebook
---

```{r}
library(gemtc)
library(rjags)
library(MASS)
```

Simulate the dataset

```{r}
source("CLNMA_functions.R")
set.seed(1)
mu1 = c(0.5,1)
mu2 = c(0,-0.5)
tau1 =c(0.25,0.36)
tau2 =c(0.36,0.16)

tau = c(tau1,tau2)
rho = matrix(c(1,0.1,0.1,0.1,0.1,1,0.1,0.1,0.1,0.1,1,0.1,0.1,0.1,0.1,1),
             nrow = 4)
tau_BC = tau1+tau2-2*rho[1,2]*sqrt(tau1*tau2)


betweenv = diag(tau)
for(i in 1:3){
  for(j in (i+1):4){
    betweenv[i,j] =betweenv[j,i]= rho[i,j]*sqrt(tau[i]*tau[j])
  }
}
ss1 =1
ss2= 1
rho_w = matrix(c(1,0.2,0.2,0.2,0.2,1,0.2,0.2,0.2,0.2,1,0.2,0.2,0.2,0.2,1),
               nrow = 4)
nab = nac=nbc=nabc=5
dataout = gendata(nab,nac,nbc,nabc,mu1,mu2,betweenv,rho_w,ss1,ss2)

```

Prepare the dataset for gemtc

$$
\begin{aligned}
& \operatorname{var}\left(y_B-y_A\right)=\operatorname{var}\left(y_B\right)+\operatorname{var}\left(y_A\right) \\
& \operatorname{var}\left(y_C-y_A\right)=\operatorname{var}\left(y_C\right)+\operatorname{var}\left(y_A\right) \\
& \operatorname{var}\left(y_B-y_C\right)=\operatorname{var}\left(y_B\right)+\operatorname{var}\left(y_C\right) \\
& \operatorname{var}(y_A)=\frac{\operatorname{var}\left(y_B-y_A\right) + \operatorname{var}\left(y_C-y_A\right) - \operatorname{var}\left(y_B-y_C\right)}{2}
\end{aligned}
$$

```{r}
# for multi-arm study( n > 2), we need to know the standard errors of reference measurement
calculate_reference_std <- function(dataset){
  var_BA = dataset[16:20, "sd"]^2
  var_CA = dataset[21:25, "sd"]^2
  var_BC = dataset[21:25, "sd"]^2
  sd_result = sqrt((var_BA + var_CA - var_BC)/2)
  study_id =  dataset[16:20, "ID"]
  result = cbind(study_id, sd_result)
  colnames(result) = c("ID", "sd") 
  return(result)
}




prepare_dataset_for_gemtc <- function(dataset){
  colnames(dataset)[4:5] = c("outcome","sd")
  reference_sd = calculate_reference_std(dataset)
  dataset = subset(dataset,  t2 != 2)
  result = NULL
  for(i in 1:nrow(dataset)){
    temp_Id = dataset[i, "ID"]
    temp_treatment=  dataset[i,"t1"]
    temp_reference = dataset[i,"t2"]
    temp_diff = dataset[i, "outcome"]
    temp_sd = dataset[i,"sd"]
    result = rbind(result, c(temp_Id, temp_treatment, temp_diff, temp_sd))
    # gemtc only allows one reference level per study
    if(sum(is.na(result[result[,1] == temp_Id,3])) == 0){
      

      if(temp_Id %in% reference_sd[,"ID"]){
   
        temp_sd = reference_sd[reference_sd[,"ID"] == temp_Id,"sd"]
        
      
      } else {
        temp_sd = NA
      }
      result = rbind(result, c(temp_Id, temp_reference, NA,temp_sd))
    }  
  }
  colnames(result) = c("study", "treatment", "diff", "std.err")
  return(result)
}
dataout1 = subset(dataout,  select = c("ID", "t1", "t2", "outcome1", "sd1"))
dataout1 = prepare_dataset_for_gemtc(dataout1)
dataout2 = subset(dataout,  select = c("ID", "t1", "t2", "outcome2", "sd2"))
dataout2 = prepare_dataset_for_gemtc(dataout2)

```


Network graph

```{r}
network1 <- mtc.network(data.re = dataout1)
network2 <- mtc.network(data.re = dataout2)
summary(network1)
```

```{r}
summary(network2)
```

model compilation

```{r}
model1 <- mtc.model(network1, 
                   linearModel = "fixed",
                   n.chain = 4)

model2 <- mtc.model(network2, 
                   linearModel = "fixed",
                   n.chain = 4)
```

mcmc simulation

```{r}
mcmc1 <- mtc.run(model1, n.adapt = 5000, n.iter = 100000, thin = 10)
mcmc2 <- mtc.run(model2, n.adapt = 5000, n.iter = 100000, thin = 10)
```

assessing the converge

```{r}
plot(mcmc1)
```

```{r}
plot(mcmc2)
```

```{r}
gelman.plot(mcmc1)
gelman.plot(mcmc2)
```

```{r}
gelman.diag(mcmc1)$mpsrf
```

```{r}
gelman.diag(mcmc2)$mpsrf
```

# inconsistency

```{r}
nodesplit1 <- mtc.nodesplit(network1, 
                          linearModel = "fixed", 
                          n.adapt = 5000, 
                          n.iter = 100000, 
                          thin = 10)

nodesplit2 <- mtc.nodesplit(network2, 
                          linearModel = "fixed", 
                          n.adapt = 5000, 
                          n.iter = 100000, 
                          thin = 10)
```

```{r}
plot(summary(nodesplit1))
```

```{r}
plot(summary(nodesplit2))
```

Generating the network meta-analysis results

```{r}
forest(relative.effect(mcmc1, t1 = 3))
```

```{r}
forest(relative.effect(mcmc2, t1 = 3))
```

